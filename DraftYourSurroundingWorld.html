<!--
Aime Serge Tuyishime
CST-310
Project Title:
Your Surrounding World
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOUR SORROUNDING WORLD</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-section {
            margin-bottom: 15px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        button {
            margin: 3px;
            padding: 10px 16px;
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        button:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .active {
            background: linear-gradient(145deg, #0066cc, #004499) !important;
            box-shadow: 0 0 20px rgba(0, 102, 204, 0.5);
        }

        .info-text {
            font-size: 11px;
            color: #bbb;
            margin-top: 10px;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="loading">Loading Enhanced Scene...</div>
    <div id="controls">
        <div class="control-section">
            <div class="control-label">Camera Views</div>
            <button id="cam1" class="active">Overview</button>
            <button id="cam2">Close-up</button>
            <button id="cam3">Detail View</button>
        </div>
        <div class="control-section">
            <div class="control-label">Lighting</div>
            <button id="daylight">Day Mode</button>
            <button id="nightlight">Night Mode</button>
        </div>
        <div class="info-text">
            Mouse: Rotate | Scroll: Zoom<br>
            Enhanced with complex meshes & realistic materials
        </div>
    </div>

    <script>
        // Scene setup with enhanced renderer settings
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f5);
        scene.fog = new THREE.Fog(0xf5f5f5, 50, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.physicallyCorrectLights = true;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Enhanced lighting system
        let isNightMode = false;
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(0, 9, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 4096;
        mainLight.shadow.mapSize.height = 4096;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 100;
        mainLight.shadow.camera.left = -30;
        mainLight.shadow.camera.right = 30;
        mainLight.shadow.camera.top = 30;
        mainLight.shadow.camera.bottom = -30;
        scene.add(mainLight);

        // Secondary lighting for better illumination
        const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
        fillLight.position.set(-10, 15, -5);
        scene.add(fillLight);

        // Enhanced materials with PBR properties
        const createMaterial = (options) => {
            return new THREE.MeshStandardMaterial({
                color: options.color || 0xffffff,
                roughness: options.roughness || 0.5,
                metalness: options.metalness || 0.0,
                normalScale: options.normalScale || new THREE.Vector2(1, 1),
                ...options
            });
        };

        // Create procedural textures for enhanced realism
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Wood grain pattern
            const gradient = ctx.createLinearGradient(0, 0, 0, 512);
            gradient.addColorStop(0, '#8B4513');
            gradient.addColorStop(0.3, '#A0522D');
            gradient.addColorStop(0.7, '#CD853F');
            gradient.addColorStop(1, '#DEB887');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add wood grain lines
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < 20; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * 25 + Math.sin(i) * 10);
                ctx.lineTo(512, i * 25 + Math.sin(i) * 10);
                ctx.stroke();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        function createMarbleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Base marble color
            ctx.fillStyle = '#f8f8ff';
            ctx.fillRect(0, 0, 512, 512);
            
            // Add marble veins
            ctx.strokeStyle = 'rgba(169, 169, 169, 0.4)';
            ctx.lineWidth = 3;
            for (let i = 0; i < 15; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * 512, 0);
                ctx.quadraticCurveTo(
                    Math.random() * 512, Math.random() * 512,
                    Math.random() * 512, 512
                );
                ctx.stroke();
            }
            
            return new THREE.CanvasTexture(canvas);
        }

        // Original floor design preserved
        function createOriginalFloor() {
            const floorGroup = new THREE.Group();
            
            // Main floor tiles (original design)
            const tileSize = 1.5;
            const tileHeight = 0.05;
            const floorWidth = 30;
            const floorDepth = 15;
            const rows = Math.floor(floorDepth / tileSize);
            const cols = Math.floor(floorWidth / tileSize);

            const lightGrayMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const darkGrayMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });

            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const isLight = (row + col) % 2 === 0;
                    const material = isLight ? lightGrayMaterial : darkGrayMaterial;

                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(tileSize, tileHeight, tileSize),
                        material
                    );

                    tile.position.set(
                        col * tileSize - floorWidth / 2 + tileSize / 2,
                        tileHeight / 2,
                        row * tileSize - floorDepth / 2 + tileSize / 2
                    );

                    tile.receiveShadow = true;
                    floorGroup.add(tile);
                }
            }

            // Main floor lines (original)
            const mainFloorLineMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const mainFloorLineThickness = 0.01;
            const mainFloorLineHeight = 0.001;
            const mainFloorLineSpacing = 0.02;
            const mainFloorLineCount = Math.floor(floorDepth / mainFloorLineSpacing);

            for (let i = 0; i < mainFloorLineCount; i++) {
                const zOffset = -floorDepth / 2 + i * mainFloorLineSpacing;
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(floorWidth, mainFloorLineHeight, mainFloorLineThickness),
                    mainFloorLineMaterial
                );
                line.position.set(0, tileHeight + 0.001, zOffset);
                floorGroup.add(line);
            }

            // Side floor (original design)
            const sideTileSize = 1.5;
            const sideTileHeight = -0.01;
            const sideFloorWidth = 30;
            const sideFloorDepth = 5;
            const sideRows = Math.floor(sideFloorDepth / sideTileSize);
            const sideCols = Math.floor(sideFloorWidth / sideTileSize);

            const lightBrownMaterial = new THREE.MeshLambertMaterial({ color: 0xD2B48C });
            const darkBrownMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });

            for (let row = 0; row < sideRows; row++) {
                for (let col = 0; col < sideCols; col++) {
                    const isLight = (row + col) % 2 === 0;
                    const material = isLight ? lightBrownMaterial : darkBrownMaterial;

                    const tile = new THREE.Mesh(
                        new THREE.BoxGeometry(sideTileSize, tileHeight, sideTileSize),
                        material
                    );

                    tile.position.set(
                        col * sideTileSize - sideCols * sideTileSize / 2 + sideTileSize / 2,
                        sideTileHeight / 2 + 0.06,
                        row * sideTileSize - sideRows * sideTileSize / 2 - 4.5
                    );

                    tile.receiveShadow = true;
                    floorGroup.add(tile);
                }
            }

            // Side floor lines (original)
            const floorLineMaterial = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
            const floorLineThickness = 0.01;
            const floorLineHeight = 0.001;
            const floorLineSpacing = 0.02;
            const floorLineCount = Math.floor(sideFloorDepth / floorLineSpacing);

            for (let i = 0; i < floorLineCount; i++) {
                const zOffset = -sideFloorDepth / 2 + i * floorLineSpacing;
                const floorLine = new THREE.Mesh(
                    new THREE.BoxGeometry(sideFloorWidth, floorLineHeight, floorLineThickness),
                    floorLineMaterial
                );
                floorLine.position.set(0, 0.08, zOffset - 5);
                floorGroup.add(floorLine);
            }

            return floorGroup;
        }

        // Original walls design preserved
        function createOriginalWalls() {
            const wallGroup = new THREE.Group();

            // Back Wall (original design)
            const wallColor = 0xFFFACD;  // light yellow-cream color
            const wallMaterial = new THREE.MeshPhongMaterial({
                color: wallColor,
                specular: 0xaaaaaa,
                shininess: 10,
            });

            const backWallGeometry = new THREE.PlaneGeometry(30, 15);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 7.5, -7.5);
            backWall.receiveShadow = true;
            wallGroup.add(backWall);

            // Left Wall (original brick pattern with red chocolate color)
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#8B2635'; // Dark red chocolate color
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const brickHeight = 40;
            const brickWidth = 80;
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;

            for (let y = 0; y < canvas.height; y += brickHeight) {
                const offset = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                for (let x = 0; x < canvas.width; x += brickWidth) {
                    ctx.strokeRect(x + offset, y, brickWidth, brickHeight);
                }
            }

            const brickTexture = new THREE.CanvasTexture(canvas);
            brickTexture.wrapS = THREE.RepeatWrapping;
            brickTexture.wrapT = THREE.RepeatWrapping;
            brickTexture.repeat.set(1, 1);

            const brickMaterial = new THREE.MeshLambertMaterial({ map: brickTexture });
            const leftWallGeometry = new THREE.PlaneGeometry(15, 15);
            const leftWall = new THREE.Mesh(leftWallGeometry, brickMaterial);
            leftWall.position.set(15, 7.5, 0);
            leftWall.rotation.y = -Math.PI / 2;
            leftWall.receiveShadow = true;
            wallGroup.add(leftWall);

            // Wainscot (original design)
            const wainscotMaterial = new THREE.MeshLambertMaterial({ color: 0xE6C9A8 });
            const wainscotGeometry = new THREE.PlaneGeometry(30, 3);
            const wainscot = new THREE.Mesh(wainscotGeometry, wainscotMaterial);
            wainscot.position.set(0, 1.5, -7.4);
            wallGroup.add(wainscot);

            // Wainscot lines (original)
            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            const lineThickness = 0.03;
            const lineLength = 30;
            const lineSpacing = 0.04;
            const numberOfLines = Math.floor(3 / lineSpacing);

            for (let i = 0; i < numberOfLines; i++) {
                const yOffset = -1.5 + i * lineSpacing;
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(lineLength, lineThickness, 0.001),
                    lineMaterial
                );
                line.position.set(0, 3 - 1.5 + yOffset, -7.39);
                wallGroup.add(line);
            }

            return wallGroup;
        }

        function createBrickTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Enhanced brick pattern with variation
            const brickColors = ['#8B4513', '#A0522D', '#CD853F', '#D2B48C'];
            const brickHeight = 40;
            const brickWidth = 80;

            for (let y = 0; y < canvas.height; y += brickHeight) {
                const offset = (y / brickHeight) % 2 === 0 ? 0 : brickWidth / 2;
                for (let x = 0; x < canvas.width; x += brickWidth) {
                    const colorIndex = Math.floor(Math.random() * brickColors.length);
                    ctx.fillStyle = brickColors[colorIndex];
                    ctx.fillRect(x + offset, y, brickWidth - 2, brickHeight - 2);
                    
                    // Add mortar
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(x + offset + brickWidth - 2, y, 2, brickHeight);
                    ctx.fillRect(x + offset, y + brickHeight - 2, brickWidth, 2);
                }
            }

            return new THREE.CanvasTexture(canvas);
        }

        // Enhanced furniture with complex geometry
        function createEnhancedTable(x, z) {
            const group = new THREE.Group();
            const woodTexture = createWoodTexture();

            // Table top with rounded edges
            const topGeometry = new THREE.BoxGeometry(2.4, 0.15, 2.4);
            const topMaterial = createMaterial({
                color: 0xD2B48C,
                map: woodTexture,
                roughness: 0.3,
                metalness: 0.0
            });

            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 3.5;
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);

            // Enhanced pedestal base with details
            const pedestalGeometry = new THREE.CylinderGeometry(0.15, 0.25, 3.4, 16);
            const pedestalMaterial = createMaterial({
                color: 0x8B4513,
                roughness: 0.4,
                metalness: 0.1
            });

            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.y = 1.75;
            pedestal.castShadow = true;
            group.add(pedestal);

            // Decorative rings on pedestal
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(0.2, 0.02, 8, 16),
                    createMaterial({ color: 0x654321, metalness: 0.3 })
                );
                ring.position.y = 1 + i * 1.2;
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
            }

            // Table base with detailed feet
            const baseMaterial = createMaterial({
                color: 0x333333,
                roughness: 0.2,
                metalness: 0.8
            });

            for (let i = 0; i < 4; i++) {
                const angle = i * (Math.PI / 2);
                
                // Main foot arm
                const arm = new THREE.Mesh(
                    new THREE.BoxGeometry(1.8, 0.1, 0.1),
                    baseMaterial
                );
                arm.position.set(
                    Math.cos(angle) * 0.9,
                    0.15,
                    Math.sin(angle) * 0.9
                );
                arm.rotation.y = angle;
                arm.castShadow = true;
                group.add(arm);

                // Foot pad
                const pad = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.15, 0.08, 16),
                    baseMaterial
                );
                pad.position.set(
                    Math.cos(angle) * 1.6,
                    0.04,
                    Math.sin(angle) * 1.6
                );
                pad.castShadow = true;
                group.add(pad);
            }

            group.position.set(x, 0, z);
            return group;
        }

        function createEnhancedChair(x, z, rotation = 0) {
            const group = new THREE.Group();

            // Seat with cushioning details
            const seatGeometry = new THREE.BoxGeometry(1.0, 0.15, 1.0);
            const seatMaterial = createMaterial({
                color: 0x9370DB,
                roughness: 0.7,
                metalness: 0.0
            });

            const seat = new THREE.Mesh(seatGeometry, seatMaterial);
            seat.position.y = 2.5;
            seat.castShadow = true;
            seat.receiveShadow = true;
            group.add(seat);

            // Add cushion padding effect
            const padding = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 0.05, 0.9),
                createMaterial({ color: 0x8A2BE2, roughness: 0.8 })
            );
            padding.position.y = 2.6;
            group.add(padding);

            // Enhanced backrest with curve
            const backGeometry = new THREE.BoxGeometry(1.0, 1.2, 0.12);
            const back = new THREE.Mesh(backGeometry, seatMaterial);
            back.position.set(0, 3.3, -0.44);
            back.rotation.x = -0.1; // Slight backward tilt
            back.castShadow = true;
            group.add(back);

            // Metal legs with realistic finish
            const legMaterial = createMaterial({
                color: 0x666666,
                roughness: 0.1,
                metalness: 0.9
            });

            for (let i = 0; i < 4; i++) {
                const legGeometry = new THREE.CylinderGeometry(0.04, 0.04, 2.5, 12);
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                const x_offset = i % 2 === 0 ? -0.4 : 0.4;
                const z_offset = i < 2 ? -0.4 : 0.4;
                leg.position.set(x_offset, 1.25, z_offset);
                leg.castShadow = true;
                group.add(leg);

                // Leg caps
                const cap = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    createMaterial({ color: 0x333333, roughness: 0.8 })
                );
                cap.position.set(x_offset, 0.05, z_offset);
                group.add(cap);
            }

            // Cross-bracing for stability
            const braceMaterial = createMaterial({
                color: 0x555555,
                roughness: 0.3,
                metalness: 0.7
            });

            // Front and back braces
            for (let side = 0; side < 2; side++) {
                const brace = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.8),
                    braceMaterial
                );
                brace.position.set(0, 0.8, side === 0 ? 0.4 : -0.4);
                brace.rotation.z = Math.PI / 2;
                group.add(brace);
            }

            // Side braces
            for (let side = 0; side < 2; side++) {
                const brace = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.8),
                    braceMaterial
                );
                brace.position.set(side === 0 ? -0.4 : 0.4, 0.8, 0);
                brace.rotation.x = Math.PI / 2;
                group.add(brace);
            }

            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            return group;
        }

        function createEnhancedArmchair(x, z, rotation = 0) {
            const group = new THREE.Group();

            // Main seat with detailed upholstery
            const seatGeometry = new THREE.BoxGeometry(1.8, 0.9, 1.6);
            const fabricMaterial = createMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.0
            });

            const seat = new THREE.Mesh(seatGeometry, fabricMaterial);
            seat.position.y = 0.7;
            seat.castShadow = true;
            seat.receiveShadow = true;
            group.add(seat);

            // Button tufting on seat
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    const button = new THREE.Mesh(
                        new THREE.SphereGeometry(0.03, 8, 8),
                        createMaterial({ color: 0x654321, metalness: 0.2 })
                    );
                    button.position.set(
                        (i - 0.5) * 0.6,
                        1.15,
                        (j - 0.5) * 0.6
                    );
                    group.add(button);
                }
            }

            // Enhanced backrest with curves
            const backGeometry = new THREE.BoxGeometry(1.8, 1.5, 0.3);
            const back = new THREE.Mesh(backGeometry, fabricMaterial);
            back.position.set(0, 1.9, -0.65);
            back.rotation.x = -0.05;
            back.castShadow = true;
            group.add(back);

            // Armrests with detailed curves
            for (let side = 0; side < 2; side++) {
                const armGeometry = new THREE.BoxGeometry(0.3, 1.2, 1.6);
                const arm = new THREE.Mesh(armGeometry, fabricMaterial);
                arm.position.set(side === 0 ? -0.75 : 0.75, 1.3, 0);
                arm.castShadow = true;
                group.add(arm);

                // Armrest padding
                const padding = new THREE.Mesh(
                    new THREE.BoxGeometry(0.25, 0.1, 1.4),
                    createMaterial({ color: 0xA0522D, roughness: 0.8 })
                );
                padding.position.set(side === 0 ? -0.75 : 0.75, 1.9, 0);
                group.add(padding);
            }

            // Wooden legs with detailed finish
            const legMaterial = createMaterial({
                color: 0x4A4A4A,
                roughness: 0.3,
                metalness: 0.1
            });

            for (let i = 0; i < 4; i++) {
                const legGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.2);
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                const x_offset = i % 2 === 0 ? -0.6 : 0.6;
                const z_offset = i < 2 ? -0.6 : 0.6;
                leg.position.set(x_offset, 0.15, z_offset);
                leg.castShadow = true;
                group.add(leg);
            }

            group.position.set(x, 0, z);
            group.rotation.y = rotation;
            return group;
        }

        // Original pendant light design preserved
        function createOriginalPendantLight(x, z) {
            const group = new THREE.Group();

            // === Transparent Lampshade (original) ===
            const shadeMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffcc,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const shadeGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 24);
            const shade = new THREE.Mesh(shadeGeometry, shadeMaterial);
            shade.position.y = 8;
            group.add(shade);

            // === Wireframe Around Lampshade (original) ===
            const radius = 0.31;
            const height = 1.2;
            const squareRows = 8;
            const squareCols = 16;
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
            const lineGroup = new THREE.Group();

            for (let j = 0; j <= squareRows; j++) {
                const ringPoints = [];
                for (let i = 0; i <= squareCols; i++) {
                    const angle = (i / squareCols) * Math.PI * 2;
                    ringPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        8 - height / 2 + (j / squareRows) * height,
                        Math.sin(angle) * radius
                    ));
                }
                const ringGeometry = new THREE.BufferGeometry().setFromPoints(ringPoints);
                lineGroup.add(new THREE.Line(ringGeometry, lineMaterial));
            }

            for (let i = 0; i < squareCols; i++) {
                const angle = (i / squareCols) * Math.PI * 2;
                const xPos = Math.cos(angle) * radius;
                const zPos = Math.sin(angle) * radius;
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(xPos, 8 - height / 2, zPos),
                    new THREE.Vector3(xPos, 8 + height / 2, zPos)
                ]);
                lineGroup.add(new THREE.Line(lineGeometry, lineMaterial));
            }

            group.add(lineGroup);

            // === Cord (original) ===
            const cord = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.01, 2),
                new THREE.MeshBasicMaterial({ color: 0x222222 })
            );
            cord.position.y = 9;
            group.add(cord);

            // === Socket (original) ===
            const socket = new THREE.Mesh(
                new THREE.CylinderGeometry(0.07, 0.07, 0.05, 6),
                new THREE.MeshPhongMaterial({ color: 0x999999, shininess: 50 })
            );
            socket.position.set(0, 8.08, 0);
            group.add(socket);

            // === Base (original) ===
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.15, 6),
                new THREE.MeshPhongMaterial({ color: 0xffffff, shininess: 30 })
            );
            base.position.set(0, 8.025, 0);
            group.add(base);

            // === Bulb (original style) ===
            const bulbGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const bulbMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffee,
                emissive: 0xffffcc,
                emissiveIntensity: 1.5,
                shininess: 100
            });
            const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
            bulb.scale.y = 1.2;
            bulb.scale.x = 0.9;
            bulb.scale.z = 0.9;
            bulb.position.set(0, 7.8, 0);
            group.add(bulb);

            // === Point Light (original) ===
            const pointLight = new THREE.PointLight(0xffffcc, 5, 7);
            pointLight.position.set(0, 7.8, 0);
            pointLight.castShadow = true;
            pointLight.shadow.mapSize.width = 1024;
            pointLight.shadow.mapSize.height = 1024;
            group.add(pointLight);

            group.position.set(x, 0, z);
            return group;
        }

        // Original trash can design preserved
        function createOriginalTrashCan(x, z, rotationY = 0) {
            const group = new THREE.Group();

            const topWidth = 1.2;
            const bottomWidth = 1;
            const depth = 1;
            const height = 2.5;

            const geometry = new THREE.BufferGeometry();
            const vertices = new Float32Array([
                -bottomWidth/2, 0, -depth/2,
                 bottomWidth/2, 0, -depth/2,
                 bottomWidth/2, 0,  depth/2,
                -bottomWidth/2, 0,  depth/2,
                -topWidth/2,    height, -depth/2,
                 topWidth/2,    height, -depth/2,
                 topWidth/2,    height,  depth/2,
                -topWidth/2,    height,  depth/2,
            ]);

            const indices = [
                0,1,5, 0,5,4,
                1,2,6, 1,6,5,
                2,3,7, 2,7,6,
                3,0,4, 3,4,7,
                4,5,6, 4,6,7,
                0,2,1, 0,3,2,
            ];

            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const body = new THREE.Mesh(
                geometry,
                new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.2, roughness: 0.6 })
            );
            body.castShadow = true;
            group.add(body);

            const lid = new THREE.Mesh(
                new THREE.BoxGeometry(topWidth + 0.1, 0.1, depth + 0.1),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            lid.position.y = height + 0.05;
            group.add(lid);

            const handle = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.05, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            handle.position.set(0, height + 0.12, 0);
            group.add(handle);

            const ridgeMaterial = new THREE.MeshStandardMaterial({ color: 0x2b2b2b });
            const ridgeGeometry = new THREE.BoxGeometry(0.03, 2, 0.01);
            const ridgePositions = [-0.4, -0.15, 0.15, 0.4];
            ridgePositions.forEach(xOffset => {
                const ridge = new THREE.Mesh(ridgeGeometry, ridgeMaterial);
                ridge.position.set(xOffset, height / 2, depth / 2 + 0.01);
                group.add(ridge);
            });

            group.position.set(x, 0.1, z);
            group.rotation.y = rotationY;
            return group;
        }

        // Enhanced wall socket with realistic details
        function createEnhancedSocket(x, y, z) {
            const socketGroup = new THREE.Group();

            // Outlet plate with realistic proportions
            const plateGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.05);
            const plateMaterial = createMaterial({
                color: 0xf8f8f8,
                roughness: 0.1,
                metalness: 0.0
            });
            const plate = new THREE.Mesh(plateGeometry, plateMaterial);
            socketGroup.add(plate);

            // Mounting screws
            for (let i = 0; i < 2; i++) {
                const screw = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.01, 8),
                    createMaterial({
                        color: 0x666666,
                        roughness: 0.2,
                        metalness: 0.8
                    })
                );
                screw.position.set(0, i === 0 ? 0.3 : -0.3, 0.03);
                screw.rotation.x = Math.PI / 2;
                socketGroup.add(screw);

                // Screw head detail
                const screwHead = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.02, 0.005),
                    createMaterial({ color: 0x555555, metalness: 0.9 })
                );
                screwHead.position.set(0, i === 0 ? 0.3 : -0.3, 0.035);
                socketGroup.add(screwHead);
            }

            // Outlet receptacles
            const receptacleGeometry = new THREE.BoxGeometry(0.35, 0.45, 0.03);
            const receptacleMaterial = createMaterial({
                color: 0xeeeeee,
                roughness: 0.2,
                metalness: 0.0
            });
            const receptacle = new THREE.Mesh(receptacleGeometry, receptacleMaterial);
            receptacle.position.z = 0.02;
            socketGroup.add(receptacle);

            // Outlet holes with realistic spacing
            const holePositions = [
                { x: 0, y: 0.12 },      // Top (ground)
                { x: -0.08, y: -0.08 }, // Bottom left (hot)
                { x: 0.08, y: -0.08 }   // Bottom right (neutral)
            ];

            holePositions.forEach(pos => {
                const hole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 0.04, 12),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                hole.position.set(pos.x, pos.y, 0.04);
                hole.rotation.x = Math.PI / 2;
                socketGroup.add(hole);

                // Metal contacts inside holes
                const contact = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.025, 0.025, 0.01, 12),
                    createMaterial({
                        color: 0xc0c0c0,
                        roughness: 0.1,
                        metalness: 0.9
                    })
                );
                contact.position.set(pos.x, pos.y, 0.035);
                contact.rotation.x = Math.PI / 2;
                socketGroup.add(contact);
            });

            socketGroup.position.set(x, y, z);
            scene.add(socketGroup);
        }

        // Original roof with lines design preserved
        function createRoofWithRotatedLines(x, y, z, rotationAngle = 0) {
            const group = new THREE.Group();

            const roofWidth = 30;
            const roofDepth = 6;
            const roofHeight = 1;
            const roof = new THREE.Mesh(
                new THREE.BoxGeometry(roofWidth, roofHeight, roofDepth),
                new THREE.MeshLambertMaterial({ color: 0xffffff })
            );
            roof.position.set(x, y, z);
            group.add(roof);

            const lineMaterial = new THREE.MeshLambertMaterial({ color: 0x999999 });
            const lineThickness = 0.05;
            const lineHeight = 0.01;
            const lineSpacing = 1.5;
            const alongZ = Math.abs(Math.cos(rotationAngle)) > 0.5;
            const lineLength = alongZ ? roofWidth : roofDepth;
            const numLines = Math.floor((alongZ ? roofDepth : roofWidth) / lineSpacing);

            for (let i = 0; i < numLines; i++) {
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(lineLength, lineHeight, lineThickness),
                    lineMaterial
                );
                line.rotation.y = rotationAngle;

                const offset = -(alongZ ? roofDepth : roofWidth) / 2 + lineSpacing * i;
                const xOffset = alongZ ? Math.sin(rotationAngle) * offset : offset;
                const zOffset = alongZ ? Math.cos(rotationAngle) * offset : 0;

                line.position.set(x + xOffset, y - roofHeight / 2 - lineHeight / 2, z + zOffset);
                group.add(line);
            }

            return group;
        }

        function createMainRoof(x, y, z) {
            const geometry = new THREE.BoxGeometry(30, 1, 15);
            const material = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const roof = new THREE.Mesh(geometry, material);
            roof.position.set(x, y, z);
            roof.castShadow = true;
            roof.receiveShadow = true;
            return roof;
        }

        // Enhanced structural elements
        function createEnhancedColumns() {
            const columnGroup = new THREE.Group();

            // Main support columns with realistic finish
            const columnMaterial = createMaterial({
                color: 0x808080,
                roughness: 0.3,
                metalness: 0.2
            });

            // Column 1
            const column1 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 15, 1),
                columnMaterial
            );
            column1.position.set(0, 7.5, -5);
            column1.castShadow = true;
            column1.receiveShadow = true;
            columnGroup.add(column1);

            // Column 2  
            const column2 = new THREE.Mesh(
                new THREE.BoxGeometry(1, 15, 1),
                columnMaterial
            );
            column2.position.set(14, 7.5, -3.5);
            column2.castShadow = true;
            column2.receiveShadow = true;
            columnGroup.add(column2);

            // Add column capitals (decorative tops)
            [column1, column2].forEach(col => {
                const capital = new THREE.Mesh(
                    new THREE.BoxGeometry(1.4, 0.3, 1.4),
                    createMaterial({
                        color: 0x999999,
                        roughness: 0.2,
                        metalness: 0.3
                    })
                );
                capital.position.copy(col.position);
                capital.position.y = 14.65;
                columnGroup.add(capital);

                // Column base
                const base = new THREE.Mesh(
                    new THREE.BoxGeometry(1.4, 0.3, 1.4),
                    createMaterial({
                        color: 0x999999,
                        roughness: 0.2,
                        metalness: 0.3
                    })
                );
                base.position.copy(col.position);
                base.position.y = 0.15;
                columnGroup.add(base);
            });

            return columnGroup;
        }

        // Environment mapping for reflective surfaces
        function createEnvironmentMap() {
            const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(256);
            const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
            scene.add(cubeCamera);
            return cubeRenderTarget.texture;
        }

        // Initialize scene with original elements preserved
        function initializeScene() {
            // Add original floor design
            scene.add(createOriginalFloor());

            // Add original walls design
            scene.add(createOriginalWalls());

            // Add enhanced structural columns
            scene.add(createEnhancedColumns());

            // Add original roof with lines
            scene.add(createRoofWithRotatedLines(0, 10, 0, Math.PI / 2));
            scene.add(createMainRoof(0, 15, 0));

            // Add enhanced furniture
            scene.add(createEnhancedTable(-5, -5));
            scene.add(createEnhancedTable(3, -5));

            // Add enhanced chairs with varied rotations
            scene.add(createEnhancedChair(-6, -5, 1.6));
            scene.add(createEnhancedChair(-3.5, -5, -1.6));
            scene.add(createEnhancedChair(-5, -3.5, Math.PI));
            scene.add(createEnhancedChair(1.5, -5, 1.6));
            scene.add(createEnhancedChair(4.5, -5, -1.6));
            scene.add(createEnhancedChair(3, -3.5, Math.PI));

            // Add enhanced armchairs
            scene.add(createEnhancedArmchair(-10, -6.1, 0));

            // Add original pendant lights
            scene.add(createOriginalPendantLight(-11, -3));
            scene.add(createOriginalPendantLight(-5, -3));
            scene.add(createOriginalPendantLight(1, -3));

            // Add original trash can
            scene.add(createOriginalTrashCan(14, -5, Math.PI / 2));

            // Add enhanced wall socket
            createEnhancedSocket(-7.5, 1.5, -7.4);

            // Add ambient details
            addAmbientDetails();

            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';
        }

        function addAmbientDetails() {}
        


        // Enhanced camera control system
        let camera_mode = 1;
        const radius = 18;
        let theta = Math.PI / 3;
        let phi = Math.PI / 4;
        let autoRotate = false;

        function updateCamera() {
            let eye;
            switch (camera_mode) {
                case 1: // Overview
                    eye = new THREE.Vector3(
                        radius * Math.sin(theta) * Math.cos(phi),
                        radius * Math.sin(theta) * Math.sin(phi) + 5,
                        radius * Math.cos(theta)
                    );
                    break;
                case 2: // Close-up
                    eye = new THREE.Vector3(
                        12 * Math.sin(theta + 0.3) * Math.cos(phi),
                        12 * Math.sin(theta + 0.3) * Math.sin(phi) + 3,
                        12 * Math.cos(theta + 0.3)
                    );
                    break;
                case 3: // Detail view
                    eye = new THREE.Vector3(
                        8 * Math.sin(theta + 0.5) * Math.cos(phi + 0.6),
                        8 * Math.sin(theta + 0.5) * Math.sin(phi + 0.6) + 2,
                        8 * Math.cos(theta + 0.5)
                    );
                    break;
            }
            camera.position.copy(eye);
            camera.lookAt(new THREE.Vector3(0, 3, -2));
        }

        // Lighting control
        function toggleLighting() {
            isNightMode = !isNightMode;
            
            if (isNightMode) {
                // Night mode
                scene.background = new THREE.Color(0x191970);
                scene.fog.color = new THREE.Color(0x191970);
                ambientLight.intensity = 0.1;
                mainLight.intensity = 0.3;
                fillLight.intensity = 0.1;
                
                // Make pendant lights more prominent
                scene.traverse((child) => {
                    if (child.isPointLight) {
                        child.intensity = 2.0;
                    }
                });
            } else {
                // Day mode
                scene.background = new THREE.Color(0xf5f5f5);
                scene.fog.color = new THREE.Color(0xf5f5f5);
                ambientLight.intensity = 0.3;
                mainLight.intensity = 1.0;
                fillLight.intensity = 0.4;
                
                scene.traverse((child) => {
                    if (child.isPointLight) {
                        child.intensity = 1.2;
                    }
                });
            }
        }

        // Enhanced mouse controls
        let mouseDown = false, mouseX = 0, mouseY = 0;

        renderer.domElement.addEventListener('mousedown', event => {
            mouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        renderer.domElement.addEventListener('mouseup', () => mouseDown = false);

        renderer.domElement.addEventListener('mousemove', event => {
            if (mouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                phi += deltaX * 0.008;
                theta = Math.max(0.1, Math.min(Math.PI - 0.1, theta + deltaY * 0.008));
                mouseX = event.clientX;
                mouseY = event.clientY;
                updateCamera();
            }
        });

        renderer.domElement.addEventListener('wheel', event => {
            event.preventDefault();
            const scale = event.deltaY > 0 ? 1.05 : 0.95;
            const newDistance = camera.position.length() * scale;
            if (newDistance > 5 && newDistance < 50) {
                camera.position.multiplyScalar(scale);
            }
        });

        // Control button event listeners
        document.getElementById('cam1').addEventListener('click', () => {
            camera_mode = 1;
            document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('cam1').classList.add('active');
            updateCamera();
        });

        document.getElementById('cam2').addEventListener('click', () => {
            camera_mode = 2;
            document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('cam2').classList.add('active');
            updateCamera();
        });

        document.getElementById('cam3').addEventListener('click', () => {
            camera_mode = 3;
            document.querySelectorAll('#controls button').forEach(b => b.classList.remove('active'));
            document.getElementById('cam3').classList.add('active');
            updateCamera();
        });

        document.getElementById('daylight').addEventListener('click', () => {
            if (isNightMode) toggleLighting();
            document.getElementById('daylight').classList.add('active');
            document.getElementById('nightlight').classList.remove('active');
        });

        document.getElementById('nightlight').addEventListener('click', () => {
            if (!isNightMode) toggleLighting();
            document.getElementById('nightlight').classList.add('active');
            document.getElementById('daylight').classList.remove('active');
        });

        // Enhanced animation loop with performance monitoring
        let frameCount = 0;
        let lastTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            frameCount++;
            
            // Auto-rotation in overview mode (subtle)
            if (camera_mode === 1) {
                phi += 0.002;
                updateCamera();
            }
            
            // Update any animated objects here
            scene.traverse((child) => {
                if (child.userData.animate) {
                    child.userData.animate(currentTime);
                }
            });
            
            renderer.render(scene, camera);
            
            // Performance monitoring (optional)
            if (currentTime - lastTime >= 1000) {
                const fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                // console.log(`FPS: ${fps}`);
            }
        }

        // Handle window resize with proper aspect ratio maintenance
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the enhanced scene
        initializeScene();
        updateCamera();
        
        // Start animation
        animate();

        // Add keyboard shortcuts for enhanced interaction
        document.addEventListener('keydown', (event) => {
            switch(event.key) {
                case '1':
                    document.getElementById('cam1').click();
                    break;
                case '2':
                    document.getElementById('cam2').click();
                    break;
                case '3':
                    document.getElementById('cam3').click();
                    break;
                case 'l':
                case 'L':
                    toggleLighting();
                    break;
                case 'r':
                case 'R':
                    // Reset camera
                    theta = Math.PI / 3;
                    phi = Math.PI / 4;
                    updateCamera();
                    break;
            }
        });

        // Add helpful console information
        console.log('Enhanced 3D Office Break Room loaded successfully!');
        console.log('Controls:');
        console.log('- Mouse: Click and drag to rotate');
        console.log('- Mouse wheel: Zoom in/out');
        console.log('- Number keys 1-3: Switch camera views');
        console.log('- L key: Toggle day/night lighting');
        console.log('- R key: Reset camera position');
    </script>
</body>
</html>